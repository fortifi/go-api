// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	stderrors "errors"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// ProductPrice Product Price
//
// swagger:model ProductPrice
type ProductPrice struct {
	Entity

	// cancel days
	CancelDays int32 `json:"cancelDays,omitempty"`

	// currency
	Currency string `json:"currency,omitempty"`

	// Interval in ISO 8601 standard
	Cycle string `json:"cycle,omitempty"`

	// cycle exact
	CycleExact string `json:"cycleExact,omitempty"`

	// cycle term
	CycleTerm int32 `json:"cycleTerm,omitempty"`

	// cycle type
	CycleType CycleTermType `json:"cycleType,omitempty"`

	// price
	Price string `json:"price,omitempty"`

	// price band fid
	PriceBandFid string `json:"priceBandFid,omitempty"`

	// product fid
	ProductFid string `json:"productFid,omitempty"`

	// setup fee
	SetupFee string `json:"setupFee,omitempty"`

	// sku fid
	SkuFid string `json:"skuFid,omitempty"`

	// suspend after days
	SuspendAfterDays int32 `json:"suspendAfterDays,omitempty"`

	// suspend style
	// Max Length: 20
	SuspendStyle string `json:"suspendStyle,omitempty"`

	// tax inclusive
	TaxInclusive bool `json:"taxInclusive,omitempty"`

	// termination fee
	TerminationFee float32 `json:"terminationFee,omitempty"`

	// termination type
	// Max Length: 15
	TerminationType string `json:"terminationType,omitempty"`

	// visibility
	Visibility int32 `json:"visibility,omitempty"`
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (m *ProductPrice) UnmarshalJSON(raw []byte) error {
	// AO0
	var aO0 Entity
	if err := swag.ReadJSON(raw, &aO0); err != nil {
		return err
	}
	m.Entity = aO0

	// AO1
	var dataAO1 struct {
		CancelDays int32 `json:"cancelDays,omitempty"`

		Currency string `json:"currency,omitempty"`

		Cycle string `json:"cycle,omitempty"`

		CycleExact string `json:"cycleExact,omitempty"`

		CycleTerm int32 `json:"cycleTerm,omitempty"`

		CycleType CycleTermType `json:"cycleType,omitempty"`

		Price string `json:"price,omitempty"`

		PriceBandFid string `json:"priceBandFid,omitempty"`

		ProductFid string `json:"productFid,omitempty"`

		SetupFee string `json:"setupFee,omitempty"`

		SkuFid string `json:"skuFid,omitempty"`

		SuspendAfterDays int32 `json:"suspendAfterDays,omitempty"`

		SuspendStyle string `json:"suspendStyle,omitempty"`

		TaxInclusive bool `json:"taxInclusive,omitempty"`

		TerminationFee float32 `json:"terminationFee,omitempty"`

		TerminationType string `json:"terminationType,omitempty"`

		Visibility int32 `json:"visibility,omitempty"`
	}
	if err := swag.ReadJSON(raw, &dataAO1); err != nil {
		return err
	}

	m.CancelDays = dataAO1.CancelDays

	m.Currency = dataAO1.Currency

	m.Cycle = dataAO1.Cycle

	m.CycleExact = dataAO1.CycleExact

	m.CycleTerm = dataAO1.CycleTerm

	m.CycleType = dataAO1.CycleType

	m.Price = dataAO1.Price

	m.PriceBandFid = dataAO1.PriceBandFid

	m.ProductFid = dataAO1.ProductFid

	m.SetupFee = dataAO1.SetupFee

	m.SkuFid = dataAO1.SkuFid

	m.SuspendAfterDays = dataAO1.SuspendAfterDays

	m.SuspendStyle = dataAO1.SuspendStyle

	m.TaxInclusive = dataAO1.TaxInclusive

	m.TerminationFee = dataAO1.TerminationFee

	m.TerminationType = dataAO1.TerminationType

	m.Visibility = dataAO1.Visibility

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (m ProductPrice) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 2)

	aO0, err := swag.WriteJSON(m.Entity)
	if err != nil {
		return nil, err
	}
	_parts = append(_parts, aO0)
	var dataAO1 struct {
		CancelDays int32 `json:"cancelDays,omitempty"`

		Currency string `json:"currency,omitempty"`

		Cycle string `json:"cycle,omitempty"`

		CycleExact string `json:"cycleExact,omitempty"`

		CycleTerm int32 `json:"cycleTerm,omitempty"`

		CycleType CycleTermType `json:"cycleType,omitempty"`

		Price string `json:"price,omitempty"`

		PriceBandFid string `json:"priceBandFid,omitempty"`

		ProductFid string `json:"productFid,omitempty"`

		SetupFee string `json:"setupFee,omitempty"`

		SkuFid string `json:"skuFid,omitempty"`

		SuspendAfterDays int32 `json:"suspendAfterDays,omitempty"`

		SuspendStyle string `json:"suspendStyle,omitempty"`

		TaxInclusive bool `json:"taxInclusive,omitempty"`

		TerminationFee float32 `json:"terminationFee,omitempty"`

		TerminationType string `json:"terminationType,omitempty"`

		Visibility int32 `json:"visibility,omitempty"`
	}

	dataAO1.CancelDays = m.CancelDays

	dataAO1.Currency = m.Currency

	dataAO1.Cycle = m.Cycle

	dataAO1.CycleExact = m.CycleExact

	dataAO1.CycleTerm = m.CycleTerm

	dataAO1.CycleType = m.CycleType

	dataAO1.Price = m.Price

	dataAO1.PriceBandFid = m.PriceBandFid

	dataAO1.ProductFid = m.ProductFid

	dataAO1.SetupFee = m.SetupFee

	dataAO1.SkuFid = m.SkuFid

	dataAO1.SuspendAfterDays = m.SuspendAfterDays

	dataAO1.SuspendStyle = m.SuspendStyle

	dataAO1.TaxInclusive = m.TaxInclusive

	dataAO1.TerminationFee = m.TerminationFee

	dataAO1.TerminationType = m.TerminationType

	dataAO1.Visibility = m.Visibility

	jsonDataAO1, errAO1 := swag.WriteJSON(dataAO1)
	if errAO1 != nil {
		return nil, errAO1
	}
	_parts = append(_parts, jsonDataAO1)
	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this product price
func (m *ProductPrice) Validate(formats strfmt.Registry) error {
	var res []error

	// validation for a type composition with Entity
	if err := m.Entity.Validate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCycleType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSuspendStyle(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTerminationType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ProductPrice) validateCycleType(formats strfmt.Registry) error {

	if swag.IsZero(m.CycleType) { // not required
		return nil
	}

	if err := m.CycleType.Validate(formats); err != nil {
		ve := new(errors.Validation)
		if stderrors.As(err, &ve) {
			return ve.ValidateName("cycleType")
		}
		ce := new(errors.CompositeError)
		if stderrors.As(err, &ce) {
			return ce.ValidateName("cycleType")
		}

		return err
	}

	return nil
}

func (m *ProductPrice) validateSuspendStyle(formats strfmt.Registry) error {

	if swag.IsZero(m.SuspendStyle) { // not required
		return nil
	}

	if err := validate.MaxLength("suspendStyle", "body", m.SuspendStyle, 20); err != nil {
		return err
	}

	return nil
}

func (m *ProductPrice) validateTerminationType(formats strfmt.Registry) error {

	if swag.IsZero(m.TerminationType) { // not required
		return nil
	}

	if err := validate.MaxLength("terminationType", "body", m.TerminationType, 15); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this product price based on the context it is used
func (m *ProductPrice) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	// validation for a type composition with Entity
	if err := m.Entity.ContextValidate(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCycleType(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ProductPrice) contextValidateCycleType(ctx context.Context, formats strfmt.Registry) error {

	if swag.IsZero(m.CycleType) { // not required
		return nil
	}

	if err := m.CycleType.ContextValidate(ctx, formats); err != nil {
		ve := new(errors.Validation)
		if stderrors.As(err, &ve) {
			return ve.ValidateName("cycleType")
		}
		ce := new(errors.CompositeError)
		if stderrors.As(err, &ce) {
			return ce.ValidateName("cycleType")
		}

		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ProductPrice) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ProductPrice) UnmarshalBinary(b []byte) error {
	var res ProductPrice
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
